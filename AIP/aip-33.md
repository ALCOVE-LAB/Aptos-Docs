---
aip: 33
title: 区块 Gas 限制
author: danielxiangzl
discussions-to (*optional): <指向官方讨论主题的URL>
Status: 起草中
last-call-end-date (*optional): <MM/DD/YYYY 最后留下反馈和评论的日期>
type: 执行
created: 05/07/2023
---

[TOC]

# AIP-33 - 区块 Gas 限制

## 一、摘要

每个区块的 Gas 限制（或简称区块 Gas 限制）是一个新特性，当一个区块中已经确认的交易集所消耗的燃料超出区块的燃料上限时，就会停止该区块的执行。这确保了每个区块的执行都在一个预先设定的计算资源或时间的范围内，从而为那些对延迟极为敏感、涉及到连续且计算量大的交易的应用保障了可预测的响应时间。



## 二、动机

提供**可预测的延迟保证**是 Aptos 区块链最关键的特性之一。例如，某些游戏应用程序期望平均延迟为2秒，当用户在游戏中铸造/转移游戏内NFT时，延迟会极大地影响用户体验。即使在系统过载时，预期高费用交易也将在 Gas 费市场下以可预测的延迟保证提交。

然而，目前高费用交易可能会在区块链面临高度顺序或计算密集型工作负载时遭受较大的延迟。这是因为执行器总是完成整个块的执行，如果执行管道包含许多计算密集型交易，这些交易的执行将导致高费用交易产生巨大的延迟。



## 三、基本原理

现有的解决方案是依赖于共识反压。如果执行管道包含太多交易，共识将受到反压以减少区块大小，然后希望减少区块执行时间，从而使执行/共识吞吐量保持一致。然而，很难预测区块链将处理的工作负载类型，因此很难设置反压机制以准确预测和调整区块执行延迟。

通过**区块 Gas 限制 (block gas limit)** 可以更准确地预测区块执行的延迟。具体来说，执行者仅提交累计燃料成本不超过区块燃料限额的那些交易，并将超出部分的交易重新放回内存池等待处理。区块 Gas 限额为区块执行时间规定了一个上限，这个上限依据的是那些连续执行而且计算量大的交易（这些交易消耗执行 Gas 而不是存储 Gas）。当每个区块的执行时间变得可以预测时，得益于共识延迟已经是可控的（常规情况下为网络通信两次往返时间），区块的提交延迟也就同样能够预测。

这种机制也与我们的 Gas 费市场很好地配合，该市场在从内存池获取交易时优先考虑具有高 Gas 费的交易。由于我们使区块执行变得快速和可预测，因此高 Gas 费交易可以比没有区块 Gas 限制时更快地包含在区块中，而在没有区块 Gas 限制时，它们可能会因提交延迟高而在内存池中滞留。



## 四、规范

概念上，如果解决了以下两个技术挑战，就能直接实现每个块的 Gas 限制：

1. 在BlockSTM的并行执行过程中，如何确定已经确认的交易序列中的哪一部分是前缀（prefix）。
2. 如何正确终止并行执行，因为线程可能因读取依赖而挂起。

我们将在下面的章节中解释我们如何解决这两个挑战。假设我们有办法解决它们，那么添加每个块的 Gas 的体限制就像在每次交易提交时更新累积的 Gas ，并在累积的 Gas 超过每个块的 Gas 限制时终止并行执行一样简单。

我们如何随着块 Gas 限制改变状态检查点逻辑有一些微妙之处，如下所述。

对于挑战1，我们已经设计并实现了[滚动提交](https://github.com/aptos-labs/aptos-core/pull/6079)，它允许 BlockSTM 准确地跟踪已提交交易的前缀。滚动提交的主要思想是记录任何交易的“wave”验证任务，类似于执行任务的“化身（incarnation）”。粗略地说，如果最新 wave 的验证任务成功，那么交易可以被提交。该算法描述的更多细节可以在[这里](https://github.com/aptos-labs/aptos-core/blob/main/aptos-move/block-executor/src/scheduler.rs#L133)的评论中找到。

对于挑战2，粗略地说，我们让一个线程标记执行的终止，解析所有交易的条件变量，并将交易的执行状态标记为 ExecutionHalted ([代码](https://github.com/aptos-labs/aptos-core/blob/daniel-per-block-gas/aptos-move/block-executor/src/scheduler.rs#L548))。任何处于等待读取依赖的线程都将被唤醒，并停止等待依赖，因为它们将读取到的执行状态为 ExecutionHalted。

对于状态检查点事务，不变性是一个块要么以重新配置事务结束，要么以状态检查点事务结束。在块气体限制更改之前，执行器将在重新配置事务之后将任何事务标记为重试。我们在这里重复使用相同的逻辑，以确保由于每个块的 Gas 限制而被中断的事务将被重试，但我们还需要插入状态检查点事务来保持不变性。详细信息可以在[这里](https://github.com/aptos-labs/aptos-core/blob/daniel-per-block-gas/execution/executor/src/components/apply_chunk_output.rs#L139)和[这里](https://github.com/aptos-labs/aptos-core/blob/daniel-per-block-gas/consensus/consensus-types/src/executed_block.rs#L122)的代码中找到。







## 五、参考实现

https://github.com/aptos-labs/aptos-core/pull/7488



## 六、风险和缺点

风险1：系统行为的变化。目前，块内的所有交易都将被执行和提交，除了纪元变化，其中重新配置交易之后的交易将被发送到内存池以进行重试，或者内部错误，其中整个块被丢弃。在更改之后，块内的交易可能只有一部分被执行和提交——一旦已提交交易的前缀超过块气体限制，其余的交易将被发送到内存池以进行重试。

风险2：块末尾的交易更有可能被块气体限制切断。这可以通过下面描述的气体感知交易洗牌来改进。



Risk 1: 系统行为的变化。目前，块内的所有交易都将被执行和提交，除了在周期（epoch ）更改时，重新配置事务之后的交易将被发送到内存池以重试，或者在整个块被丢弃的内部错误。在这种变化之后，只有一部分块内的交易可能会被执行和提交 —— 一旦已提交的交易前缀超过了块 Gas 限制，剩余的交易将被发送到内存池以重试。

Risk 2: 块末尾的交易更有可能被块 Gas 限制截断。可以通过下文描述的具有 Gas 感知的交易洗牌（shuffling）来改进这一点。



## 七、未来潜力

- 如果有必要，我们可以通过更复杂的区块 gas 限制规则来扩展设计，使其与交易执行相关联。


- 为了使 gas 费率市场与每个区块的 gas 限制更好地配合，我们可以在现有的基础上引入基于 gas 的交易洗牌机制，这是在现有的基于发送者的交易洗牌机制之上的一个补充（[AIP-27](https://github.com/aptos-foundation/AIPs/blob/main/aips/aip-27.md)）。如果我们通过将高 gas 费交易优先放置在区块的前面来对其进行优先处理，那么它们就不太可能因为区块 gas 限制而被切断。

- 为了对区块执行时间的预测更加准确，这个方案与**并行执行的 gas 机制**配合得很好。简单来说，我们希望在交易与其他交易有更多冲突时收取更多的 gas，这可以激励开发者编写更易于并行化的合约，以更好地利用我们的 BlockSTM。



## 八、建议的实现时间线

- 里程碑1（已完成）：代码完成
- 里程碑2（进行中）：修复现有的单元和端到端测试，添加更多测试

## 九、建议的部署时间线

- 里程碑1（计划）：在 v1.5 版本中切割
- 里程碑2（待定）：在开发网中进行链上配置更改
- 里程碑3（待定）：在测试网中进行链上配置更改
- 里程碑4（待定）：通过治理提案在主网中进行链上配置更改